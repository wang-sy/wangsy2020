# LeetCode刷题记录——459.重复的子字符串.md


## 题面

给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

示例 1:

> 输入: "abab"
>
> 输出: True

解释: 可由子字符串 "ab" 重复两次构成。

示例 2:

> 输入: "aba"
>
> 输出: False



示例 3:

> 输入: "abcabcabcabc"
>
> 输出: True



解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)



## 解析

这次的解析写的长一点，这题本身没啥意思，非常简单，但是想借着他去复习一下好久没复习过的kmp算法，kmp非常简单，也非常容易忘掉。kmp算法的核心就在于这个**next数组**，我们也会对他的原理进行着重讲解。当然了，你也别指望看我这个文章把它看懂了，我这里讲点虚的少敲几个字，主要讲原理，你想看实现的话，可以看我后面的代码，看代码的时候欢迎批评码风。

算法的目标就是判断一个串是否是另一个串的子串，在暴力匹配的过程中，每次都要从头再来，这样非常浪费，kmp的核心意义在于解决了这个重头再来很浪费的问题。他的核心就是构架一个next数组，next数组代表如果从这里开始不匹配了的话需要返回到哪里开始进行重新查询，它的构建方法是寻找最长公共前后缀。你可以理解为：当匹配失效时，虽然当前位置失效，但是当前位置的前一段还是可以匹配的上的，这里所说的前一段，就是整个串的前半部分的后缀，同时你又知道这个后缀和这个串的前缀是相同的，所以下次搜索的时候可以直接跳过这一段前缀进行搜索即可。

接下来需要讨论的就是next数组的构建，构建其实非常简单，这里唯一的难点就是next数组构建时不匹配的时候是如何利用已有的next数组进行向前跳转的。其实也非常简单，如果当前的没有匹配上的话我们也可以从next数组中得知最后这一段和前面的那一段相同，那么既然没法这么长了，那就只能回溯到和上一个匹配的地方继续进行比较，如果还不行的话就只能继续回溯，直到变成0.

如果你还是看不懂我在鬼扯些什么，那你最好去看看其他人写的博客和视频，我这里推荐两个：

- 博客：http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/
- 视频：从b站上直接搜kmp，去看阿三讲的那个



好了，说了一些kmp最关键的部分，接下来我们需要知道的是该怎么去利用kmp这种字符串匹配算法来解决我们现在这个题。实际上kmp最重要的是他的思想，如果你只会用kmp来做字符串匹配的话，那你只能算得上是会用kmp，但是如果你能熟练地掌握他的next数组的原理的话，那么你算得上是基本掌握了他。具体来说如果你以后看马拉车能说出一句，”就这？“的话，那你应该学得还不错。



## 代码

从这一片开始，代码直接见文件吧

