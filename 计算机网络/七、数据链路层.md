# 计算机网络之数据链路层



## 一些术语

- 节点： 主机和路由器
- 链路：连接相邻结点的通信信道（有线链路、无线链路、局域网）



数据链路层执行的任务：负责通过一条链路从一个节点向另一个物理链路直接相连的相邻节点传送数据报。



### 链路层服务

- 组帧：网络层给链路层一些数据报，网络层将他组装成帧（通过加头加尾的形式，同时完成帧同步的任务）
- 链路接入（链路访问）：如果是共享介质，需要解决信道接入，链路层寻址的时候要使用帧首部的MAC地址，用于表示源和目的（MAC和IP不同）
- 相邻节点直接的可靠交付：（和前面的差不多）
  - 对于低误码率链路，通常不使用
  - 但是对于高误码率链路（WIFI）则需要可靠交付
- 流量控制：协调相邻的发送节点和接受
- 差错检测：信号衰减、噪声
- 差错纠正：接收端直接纠正比特差错
- 全双工和半双工通信

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927153145353.png" alt="image-20200927153145353" style="zoom: 50%;" />

## 差错编码

差错编码的基础原理：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927153307260.png" alt="image-20200927153307260" style="zoom:50%;" />



我们看上面这个图，其实可以说和校验和一摸一样，对于校验和而言，这里的$f(D)$就是$SUM(D)$，当然了，不仅能够通过求和的方法来进行错误检测，还有很多的方法都可以实现相同的目标。但是这里不同的是，这里的R叫做**冗余比特**，听一下就听出来了，冗余比特比检验和要短一点。

这里的差错编码可以分为检错码和纠错码。

- 对于检错码，如果编码集的汉明距离（两两之间取，最小值） 为$d_s = r + 1$，那么这个差错编码可以检测$r$位的差错。

  <img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927153952343.png" alt="image-20200927153952343" style="zoom: 33%;" />

- 假如编码集：<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927154108681.png" style="zoom:25%;" />的汉明距离是$d_s = 2$（这里红色的是检错码）可以100%检测出1比特的差错。（这个竟然大一在离散数学的时候就做过，而且是期末考试当场想出来的，nb）

- 对于纠错码，如果编码集的汉明距离是$d_s = 2r+1$那么该纠错码可以纠正r位的错误。



这种纠错码的工作原理就是：通过添加冗余的方法，在空间中将原本相邻的码字之间的距离拉开，然后将没有意义的信号，通过汉明距离最短的方法，归入到最相似的正确编码中。

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927155300670.png" alt="image-20200927155300670" style="zoom:50%;" />

比如说，我们现在要发送两bit的信息，那么还需要加4位的纠错码，而且如果错的太多的话，还纠错纠不出来。



### 奇偶校验码

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927155550193.png" alt="image-20200927155550193" style="zoom: 50%;" />

这个方法就非常简单，检错率50%。（如果你想让他更强一些的话可以二维奇偶校验）

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927155814091.png" alt="image-20200927155814091" style="zoom:50%;" />



### InterNet校验和

这个就非常熟悉了，其实感觉这个和奇偶校验码差不多。就是在加法的过程中制定了一系列的特殊运算。







### 循环冗余校验码（CRC）

检错能力强大的差错编码，这里哈工大老师讲的太学术化了，不容易听懂，我直接列一下演算过程，大家看一下：

​	<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927164854559.png" alt="image-20200927164854559" style="zoom: 33%;" />



## 多路访问控制（MAC）协议



链路可以被分为两类：

- 点对点链路：（比如网线直连的两个电脑）
- 广播链路：共享介质的链路（总线以太网、无线局域网等等）



多路访问控制解决的问题： 在单一共享广播信道之中，两个或两个以上的节点同时传输，就会产生干扰：

- 冲突： 节点同时接受到两个或多个信号就会导致接受失败

这个时候就需要使用多路访问控制协议（MAC），对于这个协议，我们有两点期望：

- 采用分布式的算法（每个节点不需要掌握过多的信息）
- 必须基于信道本身，通信信道共享协调信息



### 理想的MAC协议

给定：R bps的广播信道。

- 当只有一个节点传输数据的时候，使用全部带宽
- 当有M个节点期望发送数据的时候，每个节点平均发送数据的速率是$R/M$
- 完全分散的控制：
  - 无需结点的协调
  - 无需时钟等等的同步



### MAC协议的分类



- 信道划分MAC协议： 使用多路复用，
- 随机访问MAC协议：信道不划分，允许冲突（冲突会失败，需要一种恢复机制）
- 轮转MAC协议：节点轮流使用信道



### TDMA协议

- 周期性接入信道，每个节点在每个周期，占用固定时间长度的时隙
- 未使用的时隙空闲

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927170242011.png" alt="image-20200927170242011" style="zoom:50%;" />

比如上面这个图，就有六个站点，但是非常显然，这样看着非常不爽，有一半的时间没干活。



### FDMA协议

将信号调制到不同的频带，每个站点分配一个固定的频段带，没有传输的时候频带空闲，如：

<img src="C:\Users\wangsy\AppData\Roaming\Typora\typora-user-images\image-20200927170418590.png" alt="image-20200927170418590" style="zoom:50%;" />

这样看起来比较好？但是如果用的人少的话，信道的利用率还是挺低的。

### 随机访问MAC协议



### 执行方法：

- 当节点要发送分组的时候：
  - 利用全部数据速率发送分组
  - 没有事先的节点间协调
- 两个或者多个节点同时发送就会冲突



所以说，就需要定义一种**冲突检测机制**，检测到冲突后，还需要定义如何从**冲突中恢复**。（比如重来）



### 时隙ALOHA协议



#### 一些假设

- 假定所有帧的大小相同
- 时间被划分成等长的时隙（每个时隙传送一个帧）
- 时隙开始的时候发送，时隙结束的时候结束
- 如果两个或两个以上的节点在同一时隙发送帧，就会冲突

#### 运行：

- 当节点有新的帧时，在下一个时隙可以发送
  - 如果冲突：在下一个时隙有概率p重传
  - 如果没冲突：在下一个时隙发送新的帧



#### 例子：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927171447731.png" alt="image-20200927171447731" style="zoom:50%;" />

高度分散化，非常简单，而且单个节点传送的时候，可以连续以满速率传输。

但是非常容易冲突，浪费时隙，并且要求所有节点的时钟同步。（我看起来感觉这个系统里面如果有很多人一起发送的话，发送的人越多，他出错的概率就越高，人越多越拉跨）

它人很多的时候，信道被成功利用的时间只有$37\%$，这也太拉跨了。



### ALOHA协议（非时隙ALOHA）

更简单，不需要时钟同步



#### 假设： 

- 当有新的帧生成的时候就直接发送



额。。。这样冲突的可能性就更大了，因为如果所有人同时发送数据的话，那么冲突的面就是时隙的长度，如果随便发的话，那么就变成了两倍的时隙的长度，因为时隙有任何冲突都会出错，经过计算可以得知：纯ALOHA协议的利用率只有$18\%$。





那么我们这里就需要思考一下，为什么他们这么慢呢？因为他们非常”自私“，每一个节点都不考虑其他节点，都在往网络里面疯狂的发协议，如果冲突了，就等一下继续发，那么网络的冲突就变成了一个随机事件，这显然是我们所不想见到的。



### CSMA协议



叫做载波监听多路访问协议：在发送之前，监听信道：

- 信道空闲：发送完整帧
- 信道忙：推迟发送
  - 1-坚持：一直坚持等待，知道空闲结束
  - 非坚持：随即等待一定时间
  - P-坚持：以概率P坚持



那么我们看到，这里我们的信道冲突仍然可能发生，这是因为，如果两个节点同时监听信道，当信道release时，同时发送数据，仍然会导致冲突。

同时，这个协议也没有考虑到网络的传输是需要时间的问题，即：监听信道得到的信息，会与实际的发送情况之间存在短暂的时延，如图所示：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927172556684.png" alt="image-20200927172556684" style="zoom: 33%;" />

同时，这个时候，B和D同时发送数据，按照CSMA的原则，就算有冲突，也需要将数据报发完，这样就又增加了非常多的时延。总结的说，就是冲突时会发生资源浪费。当然在这里可以进行小的优化：当冲突的时候，就及时停止。





### CSMA/CD协议

这个就像是我们上面说的一样，这里会在监听信道的时候，同时判断信道中是否有冲突，检测到冲突后终止发送。这样可以减少浪费，如下图所示：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927172831849.png" alt="image-20200927172831849" style="zoom:33%;" />

对于有线的网络来说，冲突检测比较易于实现，但是对于无线网络来说，冲突检测难以实现，因为无线信号强度随距离衰减过快。

需要注意的是：我们的监听有一个特点：**边发边听，不发不听**，即：冲突检测仅在发送时开启。

下面来看一个场景：



<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927173309268.png" alt="image-20200927173309268" style="zoom:50%;" />

A发送数据发送完的时候，刚好没到B，所以B发送开始时的检测没有检测到冲突，但是已发送了一点点之后，就检测到了冲突，于是就停止了发送，但是A这个时候已经发送结束了，就没有再继续监听了，但是A需要等B的信号来到A的时候才能检测到，但是如果按照”边发边听，不发不听“的话， 这里已经不发了，那就应该听不见了。如果想让A在这种条件下听到的话，A发送的数据大小必须满足：<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927173551284.png" alt="image-20200927173551284" style="zoom:33%;" />，才能在发送出去后冲突的最坏情况下，被监听到，再考虑一下 传播的其他延时，这个式子可以改写为：<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927173700897.png" alt="image-20200927173700897" style="zoom:25%;" />

来看一个例题：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927173804626.png" alt="image-20200927173804626" style="zoom:50%;" />

这个就非常尝龟，看一下，列这个式子：
$$
L_{min} / R  = 2d_{max} / V
$$
我们将：$R = 1Gbps, L_{min} = 800 bit, V = 200000km/s$带入，就可以算出距离的变换应当是$80m$，数据减少，应当缩短长度，所以选D





### 轮转访问MAC



信道划分MAC协议：

- 网络负载重的时候，共享信道效率高，非常公平
- 网络负载轻的时候，共享信道效率低

随机访问MAC协议：

- 负载重的时候：冲突开销非常大
- 负载轻的时候：效率高



轮转访问的MAC协议希望集成两者的优点。



#### 执行过程

轮询：主节点轮流邀请从属节点发送数据

典型应用：应用与一些非智能设备，

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927175948661.png" alt="image-20200927175948661" style="zoom:33%;" />

存在的问题： 存在轮询的开销（发送轮询也需要发送特定的数据帧， 存在等待延迟，存在单点故障的风险）



#### 令牌传递

控制令牌依次从一个节点传递到下一个节点，这里的令牌就是一个特殊帧，只有拿到令牌的电脑才能够发送数据。

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927180202003.png" alt="image-20200927180202003" style="zoom:50%;" />

在这个网络中也存在一定的问题：

- 令牌也有开销
- 这里也存在等待延迟
- 这里也存在单点故障的问题（电脑把令牌吞了）【解决方法：有一个主节点，如果过长时间没有令牌经过自己，那么久重新分发令牌】







### 小结



我们先来明确一下MAC的目的：在很多设备共用一个链路的时候，向多个设备分配链路资源。



<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927180501359.png" alt="image-20200927180501359" style="zoom:50%;" />



## ARP协议



我们先来回顾一下IP地址：他是一个32位的地址，标识接口的网络层地址，用于标识网络层分组，支持分组转发。

那么再来看一下MAC地址（物理地址、以太网地址、局域网地址），它的作用是在局域网内，标识一个帧从哪个接口发出，到达哪个物理相连的其他接口。48位的MAC地址固化在网卡的ROM中，有时候也可以通过软件进行设置，表示方法如下：

<img src="C:\Users\wangsy\AppData\Roaming\Typora\typora-user-images\image-20200927222556890.png" alt="image-20200927222556890" style="zoom:50%;" />

在局域网内，每块网卡应该有唯一的MAC地址

<img src="C:\Users\wangsy\AppData\Roaming\Typora\typora-user-images\image-20200927222643705.png" alt="image-20200927222643705" style="zoom:50%;" />

这里的MAC地址由IEEE同一管理和分配，网卡生产的厂商从IEEE购买一个MAC地址的区间（前24位），MAC地址就像身份证号一样，每个网卡对应一个MAC地址，不管在哪个子网内都是唯一的，并且不管到达那个子网他都是一样的，所以说他是可携带的。IP就不一样了，子网内的IP地址是不可携带的。



### ARP协议

上面在讲的都是MAC地址，我们来看ARP协议，

<img src="C:\Users\wangsy\AppData\Roaming\Typora\typora-user-images\image-20200927223405034.png" alt="image-20200927223405034" style="zoom:50%;" />

那么接下来，问题就来了，现在我们想要通过一个域名来访问一个网站，那么我们都懂，他先从DNS那里解析出来一个ip地址，然后再进行发送，但是我们就发现了问题：我们不知道目标的MAC地址。最终的问题就是：如何在已知目的接口的IP地址的前提下确认其MAC地址？



就需要来看我们的ARP协议了；



这里LAN里面的每一个节点都需要维护一个ARP表，这个表里面记录的是：
$$
<IP, MAC, TTL>
$$
这里的TTL还是原来的意思，一般设置为$20min$，当TTL到期后，这条数据会被废弃。



假设A想要给B发送数据报，并且A知道B的IP地址，那么再分发之前，就要去检索A主机的ARP表，看看有没有保存到达B主机IP地址的一个映射，假如这个时候没有发现B的IP地址与MAC地址的映射关系，这个时候就需要使用ARP协议了。

具体来说，A需要广播一个ARP查询分组，这个查询分组中，包含B的IP地址。（链路层的广播就是MAC地址全1：$FF-FF-FF-FF-FF-FF$），LAN中所有节点都会接受ARP查询。然后B就会接受ARP查询分组，IP地址匹配成功，向A应答B的MAC地址。然后A收到应答后，缓存B的MAC地址的映射关系（如果超时就重发）。ARP是一个即插即用的协议。



#### 复杂情况

上面说的情况非常简单，我们所说的广播，就是指的是在一个局域网内的广播，我们明眼人都能看的出来：如果我想连接`www.baidu.com`，那么不可能在全网广播，去找百度的MAC地址吧。

<img src="C:\Users\wangsy\AppData\Roaming\Typora\typora-user-images\image-20200927224805244.png" alt="image-20200927224805244" style="zoom:50%;" />

如果再这样的网络中，A知道B的IP地址，同时假设A知道R路由器左侧的接口的IP地址（网关的地址），那么应该怎么办呢？

其实也非常简单：

<img src="C:\Users\wangsy\AppData\Roaming\Typora\typora-user-images\image-20200927225046416.png" alt="image-20200927225046416" style="zoom:50%;" />

A需要构建一个数据报，这个数据报的IP信息仍然不变，标识从A发送到B，但是MAC地址却不直接标记B。而是标记网关的MAC地址，其实这个想法也非常好理解。就是MAC协议是在局域网内使用的，我们如果要离开当前的局域网的话，或者是要进入到子局域网中的时候，都应该重新开始规划。然后路由器转发后，更改了源、目的MAC地址：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927230534884.png" alt="image-20200927230534884" style="zoom:50%;" />

我们可以看到，在整个传输的过程中，源、目的的MAC地址是不断在变化的，而同时，源IP地址、目的IP地址是永远不变的。源、目标MAC地址发生变化的原因是，所在的局域网发生了变化。（这个说法有点抽象，也不够严谨）





## 以太网

是一种具有统治地位的LAN技术，之所以这么nb，就是因为简单、便宜。与此同时，他一直能够满足我们对网络速率的需求，我们来看一下以太网早期设计草图：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927231058841.png" alt="image-20200927231058841" style="zoom:50%;" />

可以说是非常草了。



早期的以太网使用的是总线型的拓扑结构：<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927231255794.png" alt="image-20200927231255794" style="zoom: 33%;" />，所有节点都在同一个冲突域，所谓冲突域就是在这一个域中，只要两个设备同时发送数据就会冲突，那就说这两台设备处于同一冲突域。现在我们使用的是星型拓扑，如图所示：<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927231419536.png" alt="image-20200927231419536" style="zoom:25%;" />，中心使用交换机进行数据交互。它最大的优点就是：每一个节点都有一个单独的冲突域（换句话说就是不会发生冲突）



在数据链路层中，以太网提供的是一个无连接的服务，没有握手的过程。

同时，提供的是“不可靠的服务”，接受网卡不向发送网卡进行确认。（数据出现错误后，直接对帧进行丢失，帧的还原需要依靠上层协议）

以太网的ＭＡＣ协议，采用了二进制指数退避算法的ＣＳＭＡ／ＣＤ。





### CSMA/CD



- 第一步：NIC（网卡）从网络层接收到数据报后，就会创建数据帧

- 第二步：如果NIC监听到信道是空闲的，那么就马上发送数据帧，如果信道忙，那么就等待信道空闲，然后发送数据帧（1坚持）

- 第三步：如果发送数据帧完毕之前都没有发现冲突，那么NIC就确认发送成功

- 第四步：如果发送的过程中，发现了冲突，那么久终止发送，并且发送堵塞信号（为了让别人也知道发现了冲突）

- 第五步：NIC进入二进制指数退避（通过这个算法来确定一个等待时间）

  - 第m次连续冲突后：
  - 取$n = max(m, 10)$
  - NIC从$\{0, 1,2,...,2^{n-1}\}$中随机取一个数K
  - NIC等待$K*512$比特的传输延迟时间，然后再返回第二步

  这里我们看到如果连续冲突的次数越多，那么平均等待时间就越长。

特殊的是，如果连续十六次出现拥塞， 那么协议就会向上层报告差错。



### 以太网帧的结构

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927233143096.png" alt="image-20200927233143096" style="zoom:50%;" />

- 前导码：八个字节，前7个字节全都是`10101010`，第八个字节是`10101011`，前七个字节用于时钟同步，第八个字节用于声明开始传输了。
- 目的、源MAC地址：这个不谈了，在设备收到帧的时候，会判断目的地址与本身的MAC地址是否相等，如果相等或全1，那么就接受，否则就不接受
- 类型：指示帧中封装的是哪种高层协议的分组。
- 数据Data：上层协议的载荷，我们这里无论Data有多少，必须将一个帧补全到64字节，也就是说，DATA的长度必须为46字节。
- CRC：循环冗余校验码（我们已经讲过了）



### 以太网标准

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927233658938.png" alt="image-20200927233658938" style="zoom:50%;" />

主要差别在于速率不同，以及物理介质不同



## 交换机

这里主要讲的是针对以太网的交换机。在前面的讲解中我们也了解到了，交换机是一个仅有物理层与链路层的设备，它实现的是帧的存储与转发。具体来说就是检目的的MAC地址，有选择性的进行转发。在过程中，使用CSMA/CD访问链路，发送帧。

在现代网络中，交换机大多是一种透明的设备，也就是说，主机是感受不到交换机的存在的的。也就是说，交换机是一种即插即用的设备，不需要进行配置。那么为了完成这种效果，交换机需要能够自学习。



<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200927234020499.png" alt="image-20200927234020499" style="zoom:33%;" />

总体的架构如下：

- 主机利用独享链路，直接连接交换机（不会发生冲突，或者说冲突域内仅有一台主机）
- 交换机缓存帧
- 交换机在每段链路上利用$CSMA/CD$收发帧，没有冲突，并且可以全双工
  - 这里也是因为每台计算机在一个冲突域中
- 可以并行的进行交换，不会产生冲突





### 交换机的路由表：交换表

我们都知道路由表，就是记录的IP到接口的映射信息，那么这个交换表的内容和路由表非常相近。这个交换表记录的是MAC地址到相应转发接口的映射，以及该记录的TTL。但是构造他的过程是不一样的。他是通过自学习的方法来进行构建、维护的。



#### 自学习方法

当交换机接收到帧的时候，交换机就会记忆，接受帧的接口号，以及该帧的MAC地址，那么这个时候，这个接口号和MAC地址之间就会存在着一一对应的关系，我们呢就可以将这个关系记录到交换表中。

#### 帧过滤/转发

- 当交换机收到帧之后，会记录帧的源MAC地址与输入链路接口
- 利用目的MAC地址检索交换表
  - 如果检索到目的MAC地址匹配的入口，就判断源地址与目的地址是否在同一个网段中
    - 如果在同一个网段中：那么就丢弃帧（因为连接在相同的接口上，不需要交换机转发）
    - 如果不在同一个网段中：那么就进行转发
  - 否则：泛洪，转发到该帧接口之外的所有接口





### 交换机互联

我们都知道，路由都是可以分层的。

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928002306397.png" alt="image-20200928002306397" style="zoom:33%;" />

在一个网络里面，我们只需要逐级的取泛洪，就可以查询到目的主机的MAC地址了。



### 组织机构网络

<img src="C:\Users\wangsy\AppData\Roaming\Typora\typora-user-images\image-20200928002415603.png" alt="image-20200928002415603" style="zoom:33%;" />

可以看到，这个网络的内部是使用交换机之间进行相互连接的，然后最后通过一个路由器与外部网络进行交互。那么在这里，我们路由器下的整个部分，都属于同一个IP子网，我们称这个ip子网叫做一个广播域，如下图所示：

<img src="C:\Users\wangsy\AppData\Roaming\Typora\typora-user-images\image-20200928003412308.png" alt="image-20200928003412308" style="zoom:33%;" />



### 路由器与交换机：

<img src="C:\Users\wangsy\AppData\Roaming\Typora\typora-user-images\image-20200928003632741.png" alt="image-20200928003632741" style="zoom:33%;" />



## 虚拟局域网（VLAN）



### 动机：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928003831724.png" alt="image-20200928003831724" style="zoom: 50%;" />

假设上面的图片表示的是一个学校内部组网，我们看到，他们处于一个ip子网（广播域）之中，并且他们是可以互相访问的。那么现在如果我想让他们彼此隔离应该怎么办呢？有一个非常简单暴力的方法：把下面的交换机换成路由器就隔离开了。但是这样的方法显然很笨，于是就有了虚拟局域网（VLAN）





### 基于端口的VLAN

虚拟局域网最简单的实现方法就是：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928004113836.png" alt="image-20200928004113836" style="zoom:50%;" />

直接对交换机的端口进行分组即可，不同组的端口之间不能直接进行访问。

这样做有以下几点好处：

- 流量隔离：来自、去往一个小组的帧，只会到达对应目标的端口
- 动态成员：端口可以动态的分配个给不同VLAN



那么也存在一个问题：在VLAN间转发应该怎么办呢？那就只能通过路由了（当然了，现在已经把路由器的功能内嵌到交换机中了）







同时，还存在一个问题，那就是，如果有多个交换机，想通过多个交换机维持一个分组，应该怎么办呢？于是就有了：**中继端口**。

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928004559972.png" alt="image-20200928004559972" style="zoom:50%;" />

通过中继端口传输的信息，需要携带相应的VLAN的编号信息，来指明传输的数据属于哪一个局域网。

为了标记这个信息，他插入了四个字节的信息来进行标记：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928004720966.png" alt="image-20200928004720966" style="zoom:50%;" />



## PPP协议

他执行的是**点对点的**数据链路控制，它的特点是：

- 无需介质访问控制
- 无需明确的MAC地址

执行的任务：

- 组帧：将网络层数据报封装到数据链路层帧中
  - 同时承载任何网络层协议分组
  - 可以向上层实现分用
- 比特透明传输：数据必须支持承载任何比特模式
- 差错检测（无纠正）
- 连接活性检测：检测、并向网络层通知链路失效
- 网络层地址协商：端节点可以学习/配置彼此的网络地址



### PPP数据帧

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928010652175.png" alt="image-20200928010652175" style="zoom:33%;" />



这个结构我们就非常熟悉了，不需要多提。



#### 字节填充

数据透明传输，需求：数据域必须允许包含标志模式：$<01111110>$。

- 对于发送端：在数据的$<01111110>$前添加$<01111101>$，同时也在$<01111101>$前添加$<01111101>$，这个非常好理解，就像是我们在计算机中使用的占位符`\`一样。
- 接收端：舍弃掉第一个$<01111101>$

过程如下：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928011032797.png" alt="image-20200928011032797" style="zoom:33%;" />

#### 提前准备

在交换网络层数据之前，ppp数据链路两端必须：配置PPP链路的：

- 最大帧长
- 身份认证
- 学习、配置网络层信息





## 无线局域网

先来看一些已有的协议：

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928011349960.png" alt="image-20200928011349960" style="zoom:33%;" />

它们都使用CSMA/CA多路访问控制协议。



### 体系结构

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928011440362.png" alt="image-20200928011440362" style="zoom:33%;" />

这个再正常不过了。





### 802.11AP关联

#### 被动扫描

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928011610990.png" alt="image-20200928011610990" style="zoom:33%;" />

基站主动下发信息，被主机被动接受，主机获得网络状态，得知有哪些网络。当主机选定了某一个网络后，就可以向目的主机发一个关联请求帧，如果通过了身份验证，那么AP回复一个关联响应帧。



#### 主动扫描

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928011829628.png" alt="image-20200928011829628" style="zoom:33%;" />

主机主动发送一个主动扫描帧，发送给周围的AP，AP收到后，回复一个探测响应帧，那么这个时候主机就知道自己能够访问的所有AP了。后面的流程就和被动扫描的一样了。





### 多路访问控制

目标：避免冲突

存在的瓶颈：无法一遍发送一遍进行检测



#### CSMA/CA

在这里，当我检测到信道空闲后，不能直接发送数据，而是要继续监听DIFS时间后，在进行发送数据帧，只要发送数据帧，就要发送完成。但是如果在DIFS时间内监听到信道繁忙的话：就是用随即退避算法，进行等待。对于接收方来说，发送ACK前需要监听一个较短的时间。

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928012312576.png" alt="image-20200928012312576" style="zoom:33%;" />

我们也可以发现：这里的监听时间的长短也体现了发送的优先级。



基本思想：

允许发送端“预约信道”而不是随机的发送数据帧，从而避免长数据的帧冲突，也就是：

- 发送前，先利用CSMA向BS发送一个RTS帧（非常短）
- BS收到后，广播一个CTS帧作为RTS的响应
- 其他的站点收到后暂时不使用信道



<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928012535601.png" style="zoom:33%;" />





### 帧的格式

<img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200928012618256.png" alt="image-20200928012618256" style="zoom:33%;" />



